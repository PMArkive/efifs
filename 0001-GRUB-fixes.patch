From c5c5b86e7baf3454358f02590675244f8875ab13 Mon Sep 17 00:00:00 2001
From: Pete Batard <pete@akeo.ie>
Date: Fri, 29 Nov 2024 16:46:25 +0000
Subject: [PATCH] GRUB fixes

---
 grub-core/fs/affs.c                  |  2 ++
 grub-core/fs/bfs.c                   |  2 ++
 grub-core/fs/btrfs.c                 | 52 +++++++++++++++++-----------
 grub-core/fs/cbfs.c                  |  2 +-
 grub-core/fs/cpio_common.c           |  2 +-
 grub-core/fs/erofs.c                 |  6 ++++
 grub-core/fs/f2fs.c                  |  2 ++
 grub-core/fs/fat.c                   |  8 +++--
 grub-core/fs/hfs.c                   |  6 ++++
 grub-core/fs/hfsplus.c               |  2 ++
 grub-core/fs/hfspluscomp.c           |  4 +++
 grub-core/fs/iso9660.c               | 38 +++++++++++++-------
 grub-core/fs/jfs.c                   |  6 ++--
 grub-core/fs/nilfs2.c                |  4 ++-
 grub-core/fs/ntfs.c                  |  2 ++
 grub-core/fs/proc.c                  |  2 +-
 grub-core/fs/reiserfs.c              | 16 ++++++++-
 grub-core/fs/sfs.c                   |  4 ++-
 grub-core/fs/squash4.c               | 10 ++++--
 grub-core/fs/tar.c                   |  2 +-
 grub-core/fs/udf.c                   |  2 ++
 grub-core/fs/ufs.c                   |  2 ++
 grub-core/fs/xfs.c                   |  2 ++
 grub-core/fs/zfs/zfs.c               |  6 ++--
 grub-core/fs/zfs/zfs_lz4.c           |  2 ++
 grub-core/kern/misc.c                | 12 +++----
 grub-core/lib/posix_wrap/limits.h    | 12 +++++++
 grub-core/lib/xzembed/xz_dec_lzma2.c |  2 ++
 grub-core/lib/xzembed/xz_stream.h    |  2 +-
 grub-core/lib/zstd/bitstream.h       |  2 +-
 grub-core/lib/zstd/fse_decompress.c  |  3 +-
 grub-core/lib/zstd/huf_decompress.c  |  2 +-
 grub-core/lib/zstd/mem.h             | 14 ++++++--
 grub-core/lib/zstd/xxhash.c          |  7 ++--
 grub-core/lib/zstd/zstd_common.c     |  3 +-
 grub-core/lib/zstd/zstd_decompress.c |  1 -
 grub-core/lib/zstd/zstd_internal.h   | 14 +++++++-
 include/grub/arm64/types.h           |  4 +++
 include/grub/btrfs.h                 |  3 +-
 include/grub/exfat.h                 |  2 ++
 include/grub/fat.h                   |  2 ++
 include/grub/hfs.h                   |  2 ++
 include/grub/hfsplus.h               |  6 ++++
 include/grub/misc.h                  |  5 +++
 include/grub/ntfs.h                  |  2 ++
 include/grub/safemath.h              | 24 +++++++++++++
 include/grub/term.h                  |  4 +--
 include/grub/types.h                 | 42 +++++++++++++++-------
 include/grub/unicode.h               |  2 ++
 include/grub/x86_64/types.h          |  2 +-
 include/grub/zfs/zap_leaf.h          |  2 ++
 include/grub/zfs/zio.h               |  2 ++
 52 files changed, 277 insertions(+), 87 deletions(-)

diff --git a/grub-core/fs/affs.c b/grub-core/fs/affs.c
index ed606b3f1..3f298a696 100644
--- a/grub-core/fs/affs.c
+++ b/grub-core/fs/affs.c
@@ -30,6 +30,7 @@
 GRUB_MOD_LICENSE ("GPLv3+");
 
 /* The affs bootblock.  */
+PRAGMA_BEGIN_PACKED
 struct grub_affs_bblock
 {
   grub_uint8_t type[3];
@@ -77,6 +78,7 @@ struct grub_affs_file
   grub_uint32_t extension;
   grub_uint32_t type;
 } GRUB_PACKED;
+PRAGMA_END_PACKED
 
 /* The location of `struct grub_affs_file' relative to the end of a
    file header block.  */
diff --git a/grub-core/fs/bfs.c b/grub-core/fs/bfs.c
index 9bc478ce8..2b415387a 100644
--- a/grub-core/fs/bfs.c
+++ b/grub-core/fs/bfs.c
@@ -69,6 +69,7 @@ GRUB_MOD_LICENSE ("GPLv3+");
 #define DOUBLE_INDIRECT_SHIFT 2
 
 #define LOG_EXTENT_SIZE 3
+PRAGMA_BEGIN_PACKED
 struct grub_bfs_extent
 {
   grub_uint32_t ag;
@@ -167,6 +168,7 @@ struct grub_bfs_btree_node
   grub_uint16_t total_key_len;
 #endif
 } GRUB_PACKED;
+PRAGMA_END_PACKED
 
 struct grub_bfs_data
 {
diff --git a/grub-core/fs/btrfs.c b/grub-core/fs/btrfs.c
index ba0c58352..b2299e94b 100644
--- a/grub-core/fs/btrfs.c
+++ b/grub-core/fs/btrfs.c
@@ -63,6 +63,7 @@ GRUB_MOD_LICENSE ("GPLv3+");
 typedef grub_uint8_t grub_btrfs_checksum_t[0x20];
 typedef grub_uint16_t grub_btrfs_uuid_t[8];
 
+PRAGMA_BEGIN_PACKED
 struct grub_btrfs_device
 {
   grub_uint64_t device_id;
@@ -97,6 +98,7 @@ struct btrfs_header
   grub_uint32_t nitems;
   grub_uint8_t level;
 } GRUB_PACKED;
+PRAGMA_END_PACKED
 
 struct grub_btrfs_device_desc
 {
@@ -111,8 +113,8 @@ struct grub_btrfs_data
   grub_uint64_t inode;
 
   struct grub_btrfs_device_desc *devices_attached;
-  unsigned n_devices_attached;
-  unsigned n_devices_allocated;
+  grub_size_t n_devices_attached;
+  grub_size_t n_devices_allocated;
 
   /* Cached extent data.  */
   grub_uint64_t extstart;
@@ -123,6 +125,7 @@ struct grub_btrfs_data
   struct grub_btrfs_extent_data *extent;
 };
 
+PRAGMA_BEGIN_PACKED
 struct grub_btrfs_chunk_item
 {
   grub_uint64_t size;
@@ -175,22 +178,24 @@ struct grub_btrfs_dir_item
 #define GRUB_BTRFS_DIR_ITEM_TYPE_DIRECTORY 2
 #define GRUB_BTRFS_DIR_ITEM_TYPE_SYMLINK 7
   grub_uint8_t type;
-  char name[0];
+  char name[1];
 } GRUB_PACKED;
+PRAGMA_END_PACKED
 
 struct grub_btrfs_leaf_descriptor
 {
-  unsigned depth;
-  unsigned allocated;
+  grub_size_t depth;
+  grub_size_t allocated;
   struct
   {
     grub_disk_addr_t addr;
-    unsigned iter;
-    unsigned maxiter;
+	grub_size_t iter;
+	grub_size_t maxiter;
     int leaf;
   } *data;
 };
 
+PRAGMA_BEGIN_PACKED
 struct grub_btrfs_time
 {
   grub_int64_t sec;
@@ -225,6 +230,7 @@ struct grub_btrfs_extent_data
     };
   };
 } GRUB_PACKED;
+PRAGMA_END_PACKED
 
 #define GRUB_BTRFS_EXTENT_INLINE 0
 #define GRUB_BTRFS_EXTENT_REGULAR 1
@@ -697,7 +703,7 @@ struct raid56_buffer {
   int  data_is_valid;
 };
 
-static void
+static grub_err_t
 rebuild_raid5 (char *dest, struct raid56_buffer *buffers,
 	       grub_uint64_t nstripes, grub_uint64_t csize)
 {
@@ -709,7 +715,7 @@ rebuild_raid5 (char *dest, struct raid56_buffer *buffers,
   if (i == nstripes)
     {
       grub_dprintf ("btrfs", "called rebuild_raid5(), but all disks are OK\n");
-      return;
+      return GRUB_ERR_NONE;
     }
 
   grub_dprintf ("btrfs", "rebuilding RAID 5 stripe #%" PRIuGRUB_UINT64_T "\n", i);
@@ -725,8 +731,10 @@ rebuild_raid5 (char *dest, struct raid56_buffer *buffers,
       } else
 	grub_crypto_xor (dest, dest, buffers[i].buf, csize);
     }
+  return GRUB_ERR_NONE;
 }
 
+#ifndef NO_RAID6_RECOVERY
 static grub_err_t
 raid6_recover_read_buffer (void *data, int disk_nr,
 			   grub_uint64_t addr __attribute__ ((unused)),
@@ -741,15 +749,20 @@ raid6_recover_read_buffer (void *data, int disk_nr,
 
     return grub_errno = GRUB_ERR_NONE;
 }
+#endif
 
-static void
+static grub_err_t
 rebuild_raid6 (struct raid56_buffer *buffers, grub_uint64_t nstripes,
                grub_uint64_t csize, grub_uint64_t parities_pos, void *dest,
                grub_uint64_t stripen)
 
 {
-  grub_raid6_recover_gen (buffers, nstripes, stripen, parities_pos,
-                          dest, 0, csize, 0, raid6_recover_read_buffer);
+#ifdef NO_RAID6_RECOVERY
+  return GRUB_ERR_NOT_IMPLEMENTED_YET;
+#else
+  return grub_raid6_recover_gen (buffers, nstripes, stripen, parities_pos,
+                                 dest, 0, csize, 0, raid6_recover_read_buffer);
+#endif
 }
 
 static grub_err_t
@@ -843,11 +856,10 @@ raid56_read_retry (struct grub_btrfs_data *data,
 
   /* We have enough disks. So, rebuild the data. */
   if (chunk_type & GRUB_BTRFS_CHUNK_TYPE_RAID5)
-    rebuild_raid5 (buf, buffers, nstripes, csize);
+    ret = rebuild_raid5 (buf, buffers, nstripes, csize);
   else
-    rebuild_raid6 (buffers, nstripes, csize, parities_pos, buf, stripen);
+    ret = rebuild_raid6 (buffers, nstripes, csize, parities_pos, buf, stripen);
 
-  ret = GRUB_ERR_NONE;
  cleanup:
   if (buffers)
     for (i = 0; i < nstripes; i++)
@@ -965,8 +977,8 @@ grub_btrfs_read_logical (struct grub_btrfs_data *data, grub_disk_addr_t addr,
 			       "couldn't find the chunk descriptor");
 	  }
 
-	nstripes = grub_le_to_cpu16 (chunk->nstripes) ? : 1;
-	chunk_stripe_length = grub_le_to_cpu64 (chunk->stripe_length) ? : 512;
+	nstripes = grub_le_to_cpu16 (chunk->nstripes) ? grub_le_to_cpu16(chunk->nstripes) : 1;
+	chunk_stripe_length = grub_le_to_cpu64 (chunk->stripe_length) ? grub_le_to_cpu64(chunk->stripe_length) : 512;
 	grub_dprintf ("btrfs", "chunk 0x%" PRIxGRUB_UINT64_T
 		      "+0x%" PRIxGRUB_UINT64_T
 		      " (%d stripes (%d substripes) of %"
@@ -1052,13 +1064,13 @@ grub_btrfs_read_logical (struct grub_btrfs_data *data, grub_disk_addr_t addr,
 	      grub_uint64_t middle, high;
 	      grub_uint64_t low;
 	      grub_uint16_t nsubstripes;
-	      nsubstripes = grub_le_to_cpu16 (chunk->nsubstripes) ? : 1;
+	      nsubstripes = grub_le_to_cpu16 (chunk->nsubstripes) ? grub_le_to_cpu16(chunk->nsubstripes)  : 1;
 	      middle = grub_divmod64 (off,
 				      chunk_stripe_length,
 				      &low);
 
 	      high = grub_divmod64 (middle,
-				    nstripes / nsubstripes ? : 1,
+				    nstripes / nsubstripes ? nstripes / nsubstripes : 1,
 				    &stripen);
 	      stripen *= nsubstripes;
 	      redundancy = nsubstripes;
@@ -1335,7 +1347,7 @@ static void *grub_zstd_malloc (void *state __attribute__((unused)), size_t size)
 
 static void grub_zstd_free (void *state __attribute__((unused)), void *address)
 {
-  return grub_free (address);
+  grub_free (address);
 }
 
 static ZSTD_customMem grub_zstd_allocator (void)
diff --git a/grub-core/fs/cbfs.c b/grub-core/fs/cbfs.c
index 8ab7106af..b391277c7 100644
--- a/grub-core/fs/cbfs.c
+++ b/grub-core/fs/cbfs.c
@@ -44,7 +44,7 @@ struct grub_archelp_data
 static grub_err_t
 grub_cbfs_find_file (struct grub_archelp_data *data, char **name,
 		     grub_int32_t *mtime,
-		     grub_uint32_t *mode)
+		     grub_archelp_mode_t *mode)
 {
   grub_size_t offset;
   for (;;
diff --git a/grub-core/fs/cpio_common.c b/grub-core/fs/cpio_common.c
index 5d41b6fdb..042870715 100644
--- a/grub-core/fs/cpio_common.c
+++ b/grub-core/fs/cpio_common.c
@@ -43,7 +43,7 @@ struct grub_archelp_data
 
 static grub_err_t
 grub_cpio_find_file (struct grub_archelp_data *data, char **name,
-		     grub_int32_t *mtime, grub_uint32_t *mode)
+		     grub_int32_t *mtime, grub_archelp_mode_t *mode)
 {
   struct head hd;
   grub_size_t namesize;
diff --git a/grub-core/fs/erofs.c b/grub-core/fs/erofs.c
index f2a82e988..c56918e71 100644
--- a/grub-core/fs/erofs.c
+++ b/grub-core/fs/erofs.c
@@ -37,6 +37,7 @@ GRUB_MOD_LICENSE ("GPLv3+");
 #define EROFS_FEATURE_INCOMPAT_CHUNKED_FILE	0x00000004
 #define EROFS_ALL_FEATURE_INCOMPAT		EROFS_FEATURE_INCOMPAT_CHUNKED_FILE
 
+PRAGMA_BEGIN_PACKED
 struct grub_erofs_super
 {
   grub_uint32_t		magic;
@@ -71,6 +72,7 @@ struct grub_erofs_super
   grub_uint64_t		packed_nid;
   grub_uint8_t		reserved2[24];
 } GRUB_PACKED;
+PRAGMA_END_PACKED
 
 #define EROFS_INODE_LAYOUT_COMPACT	0
 #define EROFS_INODE_LAYOUT_EXTENDED	1
@@ -87,11 +89,13 @@ struct grub_erofs_super
 #define EROFS_I_VERSION_BIT	0
 #define EROFS_I_DATALAYOUT_BIT	1
 
+PRAGMA_BEGIN_PACKED
 struct grub_erofs_inode_chunk_info
 {
   grub_uint16_t		format;
   grub_uint16_t		reserved;
 } GRUB_PACKED;
+PRAGMA_END_PACKED
 
 #define EROFS_CHUNK_FORMAT_BLKBITS_MASK	0x001F
 #define EROFS_CHUNK_FORMAT_INDEXES	0x0020
@@ -122,6 +126,7 @@ union grub_erofs_inode_i_u
   struct grub_erofs_inode_chunk_info	c;
 };
 
+PRAGMA_BEGIN_PACKED
 struct grub_erofs_inode_compact
 {
   grub_uint16_t			i_format;
@@ -183,6 +188,7 @@ struct grub_erofs_dirent
   grub_uint8_t		file_type;
   grub_uint8_t		reserved;
 } GRUB_PACKED;
+PRAGMA_END_PACKED
 
 struct grub_erofs_map_blocks
 {
diff --git a/grub-core/fs/f2fs.c b/grub-core/fs/f2fs.c
index 855e24618..273ff806d 100644
--- a/grub-core/fs/f2fs.c
+++ b/grub-core/fs/f2fs.c
@@ -132,6 +132,7 @@ enum FILE_TYPE
   F2FS_FT_SYMLINK                 = 7
 };
 
+PRAGMA_BEGIN_PACKED
 struct grub_f2fs_superblock
 {
   grub_uint32_t                   magic;
@@ -282,6 +283,7 @@ struct grub_f2fs_node
   };
   grub_uint8_t                    dummy[40];
 } GRUB_PACKED;
+PRAGMA_END_PACKED
 
 struct grub_fshelp_node
 {
diff --git a/grub-core/fs/fat.c b/grub-core/fs/fat.c
index c5efed724..0ce1eb6da 100644
--- a/grub-core/fs/fat.c
+++ b/grub-core/fs/fat.c
@@ -76,6 +76,7 @@ enum
   {
     FLAG_CONTIGUOUS = 2
   };
+PRAGMA_BEGIN_PACKED
 struct grub_fat_dir_entry
 {
   grub_uint8_t entry_type;
@@ -116,6 +117,7 @@ struct grub_fat_dir_entry
     }  GRUB_PACKED  volume_label;
   }  GRUB_PACKED type_specific;
 } GRUB_PACKED;
+PRAGMA_END_PACKED
 
 struct grub_fat_dir_node
 {
@@ -130,6 +132,7 @@ struct grub_fat_dir_node
 typedef struct grub_fat_dir_node grub_fat_dir_node_t;
 
 #else
+PRAGMA_BEGIN_PACKED
 struct grub_fat_dir_entry
 {
   grub_uint8_t name[11];
@@ -157,6 +160,7 @@ struct grub_fat_long_name_entry
   grub_uint16_t first_cluster;
   grub_uint16_t name3[2];
 } GRUB_PACKED;
+PRAGMA_END_PACKED
 
 typedef struct grub_fat_dir_entry grub_fat_dir_node_t;
 
@@ -728,7 +732,7 @@ grub_fat_iterate_dir_next (grub_fshelp_node_t node,
       grub_dprintf ("exfat", "unknown primary type 0x%02x\n",
 		    dir->entry_type);
     }
-  return grub_errno ? : GRUB_ERR_EOF;
+  return grub_errno ? grub_errno : GRUB_ERR_EOF;
 }
 
 /*
@@ -882,7 +886,7 @@ grub_fat_iterate_dir_next (grub_fshelp_node_t node,
       return GRUB_ERR_NONE;
     }
 
-  return grub_errno ? : GRUB_ERR_EOF;
+  return grub_errno ? grub_errno : GRUB_ERR_EOF;
 }
 
 /*
diff --git a/grub-core/fs/hfs.c b/grub-core/fs/hfs.c
index 91dc0e69c..56a44ddae 100644
--- a/grub-core/fs/hfs.c
+++ b/grub-core/fs/hfs.c
@@ -59,6 +59,7 @@ enum grub_hfs_cnid_type
   };
 
 /* A node descriptor.  This is the header of every node.  */
+PRAGMA_BEGIN_PACKED
 struct grub_hfs_node
 {
   grub_uint32_t next;
@@ -84,6 +85,7 @@ struct grub_hfs_treeheader
   grub_uint32_t free_nodes;
   grub_uint8_t unused[76];
 } GRUB_PACKED;
+PRAGMA_END_PACKED
 
 /* The state of a mounted HFS filesystem.  */
 struct grub_hfs_data
@@ -104,6 +106,7 @@ struct grub_hfs_data
 
 /* The key as used on disk in a catalog tree.  This is used to lookup
    file/directory nodes by parent directory ID and filename.  */
+PRAGMA_BEGIN_PACKED
 struct grub_hfs_catalog_key
 {
   grub_uint8_t unused;
@@ -157,6 +160,7 @@ struct grub_hfs_filerec
      in the extent overflow file.  */
   grub_hfs_datarecord_t extents;
 } GRUB_PACKED;
+PRAGMA_END_PACKED
 
 /* A record descriptor, both key and data, used to pass to call back
    functions.  */
@@ -721,11 +725,13 @@ grub_hfs_iterate_records (struct grub_hfs_data *data, int type, int idx,
       for (i = 0; i < reccnt; i++)
 	{
 	  int pos = (nodesize >> 1) - 1 - i;
+	  PRAGMA_BEGIN_PACKED
  	  struct pointer
 	  {
 	    grub_uint8_t keylen;
 	    grub_uint8_t key;
 	  } GRUB_PACKED *pnt;
+	  PRAGMA_END_PACKED
 	  grub_uint16_t off = grub_be_to_cpu16 (node->offsets[pos]);
 	  if (off > nodesize - sizeof(*pnt))
 	    continue;
diff --git a/grub-core/fs/hfsplus.c b/grub-core/fs/hfsplus.c
index 295822f69..dd5a39f49 100644
--- a/grub-core/fs/hfsplus.c
+++ b/grub-core/fs/hfsplus.c
@@ -45,6 +45,7 @@ enum grub_hfsplus_btnode_type
   };
 
 /* The header of a HFS+ B+ Tree.  */
+PRAGMA_BEGIN_PACKED
 struct grub_hfsplus_btheader
 {
   grub_uint16_t depth;
@@ -77,6 +78,7 @@ struct grub_hfsplus_catfile
   struct grub_hfsplus_forkdata data;
   struct grub_hfsplus_forkdata resource;
 } GRUB_PACKED;
+PRAGMA_END_PACKED
 
 /* Filetype information as used in inodes.  */
 #define GRUB_HFSPLUS_FILEMODE_MASK	0170000
diff --git a/grub-core/fs/hfspluscomp.c b/grub-core/fs/hfspluscomp.c
index 48ae438d8..c5875dc16 100644
--- a/grub-core/fs/hfspluscomp.c
+++ b/grub-core/fs/hfspluscomp.c
@@ -28,6 +28,7 @@
 GRUB_MOD_LICENSE ("GPLv3+");
 
 /* big-endian.  */
+PRAGMA_BEGIN_PACKED
 struct grub_hfsplus_compress_header1
 {
   grub_uint32_t header_size;
@@ -48,6 +49,7 @@ struct grub_hfsplus_compress_header3
 {
   grub_uint32_t num_chunks;
 } GRUB_PACKED;
+PRAGMA_END_PACKED
 
 /* little-endian.  */
 struct grub_hfsplus_compress_block_descriptor
@@ -56,6 +58,7 @@ struct grub_hfsplus_compress_block_descriptor
   grub_uint32_t size;
 };
 
+PRAGMA_BEGIN_PACKED
 struct grub_hfsplus_compress_end_descriptor
 {
   grub_uint8_t always_the_same[50];
@@ -76,6 +79,7 @@ struct grub_hfsplus_compress_attr
   grub_uint32_t uncompressed_inline_size;
   grub_uint32_t always_0;
 } GRUB_PACKED;
+PRAGMA_END_PACKED
 
 enum
   {
diff --git a/grub-core/fs/iso9660.c b/grub-core/fs/iso9660.c
index 8c348b59a..0425ea2bf 100644
--- a/grub-core/fs/iso9660.c
+++ b/grub-core/fs/iso9660.c
@@ -53,6 +53,7 @@ GRUB_MOD_LICENSE ("GPLv3+");
 #define GRUB_ISO9660_MAX_CE_HOPS	100000
 
 /* The head of a volume descriptor.  */
+PRAGMA_BEGIN_PACKED
 struct grub_iso9660_voldesc
 {
   grub_uint8_t type;
@@ -133,8 +134,18 @@ struct grub_iso9660_susp_entry
 {
   grub_uint8_t sig[2];
   grub_uint8_t len;
-  grub_uint8_t version;
-  grub_uint8_t data[0];
+/*! MSVC compilers cannot handle a zero sized array in the middle
+    of a struct, and grub_iso9660_susp_entry is reused within
+    grub_iso9660_susp_ce. Therefore, instead of defining:
+        grub_uint8_t version;
+        grub_uint8_t data[];
+    we leverage the fact that these attributes are the same size
+    and use an union. The only gotcha is that the actual
+    payload of u.data[] starts at 1, not 0. */
+  union {
+    grub_uint8_t  version;
+    grub_uint8_t  data[1];
+  } u;
 } GRUB_PACKED;
 
 /* The CE entry.  This is used to describe the next block where data
@@ -149,6 +160,7 @@ struct grub_iso9660_susp_ce
   grub_uint32_t len;
   grub_uint32_t len_be;
 } GRUB_PACKED;
+PRAGMA_END_PACKED
 
 struct grub_iso9660_data
 {
@@ -473,7 +485,7 @@ set_rockridge (struct grub_iso9660_data *data)
        * The 2nd data byte stored how many bytes are skipped every time
        * to get to the SUA (System Usage Area).
        */
-      data->susp_skip = entry->data[2];
+      data->susp_skip = entry->u.data[1 + 2];
       entry = (struct grub_iso9660_susp_entry *) ((char *) entry + entry->len);
 
       /* Iterate over the entries in the SUA area to detect
@@ -624,9 +636,9 @@ susp_iterate_dir (struct grub_iso9660_susp_entry *entry,
       /* The flags are stored at the data position 0, here the
 	 filename type is stored.  */
       /* FIXME: Fix this slightly improper cast.  */
-      if (entry->data[0] & GRUB_ISO9660_RR_DOT)
+      if (entry->u.data[1 + 0] & GRUB_ISO9660_RR_DOT)
 	ctx->filename = (char *) ".";
-      else if (entry->data[0] & GRUB_ISO9660_RR_DOTDOT)
+      else if (entry->u.data[1 + 0] & GRUB_ISO9660_RR_DOTDOT)
 	ctx->filename = (char *) "..";
       else if (entry->len >= 5)
 	{
@@ -657,7 +669,7 @@ susp_iterate_dir (struct grub_iso9660_susp_entry *entry,
 	      return grub_errno;
 	    }
 	  ctx->filename_alloc = 1;
-	  grub_memcpy (ctx->filename + off, (char *) &entry->data[1], csize);
+	  grub_memcpy (ctx->filename + off, (char *) &entry->u.data[1 + 1], csize);
 	  ctx->filename[off + csize] = '\0';
 	}
     }
@@ -666,7 +678,7 @@ susp_iterate_dir (struct grub_iso9660_susp_entry *entry,
     {
       /* At position 0 of the PX record the st_mode information is
 	 stored (little-endian).  */
-      grub_uint32_t mode = ((entry->data[0] + (entry->data[1] << 8))
+      grub_uint32_t mode = ((entry->u.data[1 + 0] + (entry->u.data[1 + 1] << 8))
 			    & GRUB_ISO9660_FSTYPE_MASK);
 
       switch (mode)
@@ -700,12 +712,12 @@ susp_iterate_dir (struct grub_iso9660_susp_entry *entry,
 	   * "Component Flags"; entry->data[pos + 1] is the length
 	   * of the component.
 	   */
-          csize = entry->data[pos + 1] + 2;
+          csize = entry->u.data[1 + pos + 1] + 2;
           if (GRUB_ISO9660_SUSP_HEADER_SZ + 1 + csize > entry->len)
             break;
 
 	  /* The current position is the `Component Flag'.  */
-	  switch (entry->data[pos] & 30)
+	  switch (entry->u.data[1 + pos] & 30)
 	    {
 	    case 0:
 	      {
@@ -719,9 +731,9 @@ susp_iterate_dir (struct grub_iso9660_susp_entry *entry,
 		      return grub_errno;
 		  }
 
-		add_part (ctx, (char *) &entry->data[pos + 2],
-			  entry->data[pos + 1]);
-		ctx->was_continue = (entry->data[pos] & 1);
+		add_part (ctx, (char *) &entry->u.data[1 + pos + 2],
+			  entry->u.data[1 + pos + 1]);
+		ctx->was_continue = (entry->u.data[1 + pos] & 1);
 		break;
 	      }
 
@@ -744,7 +756,7 @@ susp_iterate_dir (struct grub_iso9660_susp_entry *entry,
 
 	  /* In pos + 1 the length of the `Component Record' is
 	     stored.  */
-	  pos += entry->data[pos + 1] + 2;
+	  pos += entry->u.data[1 + pos + 1] + 2;
 	}
 
       /* Check if `grub_realloc' failed.  */
diff --git a/grub-core/fs/jfs.c b/grub-core/fs/jfs.c
index 62e20ef6f..e1a3b8b1a 100644
--- a/grub-core/fs/jfs.c
+++ b/grub-core/fs/jfs.c
@@ -61,6 +61,7 @@ struct grub_jfs_sblock
   char volname2[16];
 };
 
+PRAGMA_BEGIN_PACKED
 struct grub_jfs_extent
 {
   /* The length of the extent in filesystem blocks.  */
@@ -252,10 +253,11 @@ struct grub_jfs_diropen
   char name[256 * GRUB_MAX_UTF8_PER_UTF16 + 1];
   grub_uint32_t ino;
 } GRUB_PACKED;
-
+PRAGMA_END_PACKED
 
 static grub_dl_t my_mod;
-
+
+
 static grub_err_t grub_jfs_lookup_symlink (struct grub_jfs_data *data, grub_uint32_t ino);
 
 static grub_int64_t
diff --git a/grub-core/fs/nilfs2.c b/grub-core/fs/nilfs2.c
index fc7374ead..f62f7788d 100644
--- a/grub-core/fs/nilfs2.c
+++ b/grub-core/fs/nilfs2.c
@@ -132,6 +132,7 @@ struct grub_nilfs2_super_block
   grub_uint32_t s_reserved[192];
 };
 
+PRAGMA_BEGIN_PACKED
 struct grub_nilfs2_dir_entry
 {
   grub_uint64_t inode;
@@ -144,6 +145,7 @@ struct grub_nilfs2_dir_entry
   char pad;
 #endif
 } GRUB_PACKED;
+PRAGMA_END_PACKED
 
 enum
 {
@@ -753,7 +755,7 @@ static grub_err_t
 grub_nilfs2_load_sb (struct grub_nilfs2_data *data)
 {
   grub_disk_t disk = data->disk;
-  struct grub_nilfs2_super_block sb2;
+  struct grub_nilfs2_super_block sb2 = { 0 };
   grub_uint64_t partition_size;
   int valid[2];
   int swp = 0;
diff --git a/grub-core/fs/ntfs.c b/grub-core/fs/ntfs.c
index de435aa14..b44f5381b 100644
--- a/grub-core/fs/ntfs.c
+++ b/grub-core/fs/ntfs.c
@@ -689,6 +689,7 @@ list_file (struct grub_ntfs_file *diro, grub_uint8_t *pos, grub_uint8_t *end_pos
   return 0;
 }
 
+PRAGMA_BEGIN_PACKED
 struct symlink_descriptor
 {
   grub_uint32_t type;
@@ -698,6 +699,7 @@ struct symlink_descriptor
   grub_uint16_t off2;
   grub_uint16_t len2;
 } GRUB_PACKED;
+PRAGMA_END_PACKED
 
 static char *
 grub_ntfs_read_symlink (grub_fshelp_node_t node)
diff --git a/grub-core/fs/proc.c b/grub-core/fs/proc.c
index 5f516502d..06217f58b 100644
--- a/grub-core/fs/proc.c
+++ b/grub-core/fs/proc.c
@@ -90,7 +90,7 @@ grub_procfs_rewind (struct grub_archelp_data *data)
 static grub_err_t
 grub_procfs_find_file (struct grub_archelp_data *data, char **name,
 		     grub_int32_t *mtime,
-		     grub_uint32_t *mode)
+		     grub_archelp_mode_t *mode)
 {
   data->entry = data->next_entry;
   if (!data->entry)
diff --git a/grub-core/fs/reiserfs.c b/grub-core/fs/reiserfs.c
index 36b26ac98..3c001897e 100644
--- a/grub-core/fs/reiserfs.c
+++ b/grub-core/fs/reiserfs.c
@@ -42,15 +42,27 @@
 
 GRUB_MOD_LICENSE ("GPLv3+");
 
+#ifndef _MSC_VER
+#ifndef MIN
 #define MIN(a, b) \
   ({ typeof (a) _a = (a); \
      typeof (b) _b = (b); \
      _a < _b ? _a : _b; })
-
+#endif
+#ifndef MAX
 #define MAX(a, b) \
   ({ typeof (a) _a = (a); \
      typeof (b) _b = (b); \
      _a > _b ? _a : _b; })
+#endif
+#else
+#ifndef MIN
+#define MIN(a, b) ((a)<(b)?(a):(b))
+#endif
+#ifndef MAX
+#define MAX(a, b) ((a)>(b)?(a):(b))
+#endif
+#endif
 
 #define REISERFS_SUPER_BLOCK_OFFSET 0x10000
 #define REISERFS_MAGIC_LEN 12
@@ -82,6 +94,7 @@ enum grub_reiserfs_item_type
     GRUB_REISERFS_UNKNOWN
   };
 
+PRAGMA_BEGIN_PACKED
 struct grub_reiserfs_superblock
 {
   grub_uint32_t block_count;
@@ -217,6 +230,7 @@ struct grub_reiserfs_directory_header
   grub_uint16_t location;
   grub_uint16_t state;
 } GRUB_PACKED;
+PRAGMA_END_PACKED
 
 struct grub_fshelp_node
 {
diff --git a/grub-core/fs/sfs.c b/grub-core/fs/sfs.c
index 983e88008..337700914 100644
--- a/grub-core/fs/sfs.c
+++ b/grub-core/fs/sfs.c
@@ -31,6 +31,7 @@
 GRUB_MOD_LICENSE ("GPLv3+");
 
 /* The common header for a block.  */
+PRAGMA_BEGIN_PACKED
 struct grub_sfs_bheader
 {
   grub_uint8_t magic[4];
@@ -122,8 +123,9 @@ struct grub_sfs_btree
      supported.  */
   struct grub_sfs_btree_node node[1];
 } GRUB_PACKED;
+PRAGMA_END_PACKED
+
 
-
 
 struct cache_entry
 {
diff --git a/grub-core/fs/squash4.c b/grub-core/fs/squash4.c
index a30e6ebe1..65798008d 100644
--- a/grub-core/fs/squash4.c
+++ b/grub-core/fs/squash4.c
@@ -51,6 +51,7 @@ GRUB_MOD_LICENSE ("GPLv3+");
   unk2 containts one uint64_t
 */
 
+PRAGMA_BEGIN_PACKED
 struct grub_squash_super
 {
   grub_uint32_t magic;
@@ -89,7 +90,7 @@ struct grub_squash_inode
       grub_uint32_t fragment;
       grub_uint32_t offset;
       grub_uint32_t size;
-      grub_uint32_t block_size[0];
+      grub_uint32_t block_size[1];
     }  GRUB_PACKED file;
     struct {
       grub_uint64_t chunk;
@@ -98,7 +99,7 @@ struct grub_squash_inode
       grub_uint32_t fragment;
       grub_uint32_t offset;
       grub_uint32_t dummy3;
-      grub_uint32_t block_size[0];
+      grub_uint32_t block_size[1];
     }  GRUB_PACKED long_file;
     struct {
       grub_uint32_t chunk;
@@ -117,10 +118,11 @@ struct grub_squash_inode
     struct {
       grub_uint32_t dummy;
       grub_uint32_t namelen;
-      char name[0];
+      char name[1];
     } GRUB_PACKED symlink;
   }  GRUB_PACKED;
 } GRUB_PACKED;
+PRAGMA_END_PACKED
 
 struct grub_squash_cache_inode
 {
@@ -131,6 +133,7 @@ struct grub_squash_cache_inode
   grub_disk_addr_t *cumulated_block_sizes;
 };
 
+PRAGMA_BEGIN_PACKED
 /* Chunk-based.  */
 struct grub_squash_dirent_header
 {
@@ -166,6 +169,7 @@ struct grub_squash_frag_desc
   grub_uint32_t size;
   grub_uint32_t dummy;
 } GRUB_PACKED;
+PRAGMA_END_PACKED
 
 enum
   {
diff --git a/grub-core/fs/tar.c b/grub-core/fs/tar.c
index c551ed6b5..b1822f095 100644
--- a/grub-core/fs/tar.c
+++ b/grub-core/fs/tar.c
@@ -72,7 +72,7 @@ struct grub_archelp_data
 static grub_err_t
 grub_cpio_find_file (struct grub_archelp_data *data, char **name,
 		     grub_int32_t *mtime,
-		     grub_uint32_t *mode)
+		     grub_archelp_mode_t *mode)
 {
   struct head hd;
   int reread = 0, have_longname = 0, have_longlink = 0;
diff --git a/grub-core/fs/udf.c b/grub-core/fs/udf.c
index b836e6107..bfec4ef49 100644
--- a/grub-core/fs/udf.c
+++ b/grub-core/fs/udf.c
@@ -118,6 +118,7 @@ GRUB_MOD_LICENSE ("GPLv3+");
   ((char *) (_ptr) >= end_ptr || \
    ((grub_ssize_t) (end_ptr - (char *) (_ptr)) < (grub_ssize_t) sizeof (_struct)))
 
+PRAGMA_BEGIN_PACKED
 struct grub_udf_lb_addr
 {
   grub_uint32_t block_num;
@@ -375,6 +376,7 @@ struct grub_udf_aed
   grub_uint32_t prev_ae;
   grub_uint32_t ae_len;
 } GRUB_PACKED;
+PRAGMA_END_PACKED
 
 struct grub_udf_data
 {
diff --git a/grub-core/fs/ufs.c b/grub-core/fs/ufs.c
index a354c92d9..92d2020a8 100644
--- a/grub-core/fs/ufs.c
+++ b/grub-core/fs/ufs.c
@@ -152,6 +152,7 @@ struct grub_ufs_sblock
   grub_uint32_t magic;
 };
 
+PRAGMA_BEGIN_PACKED
 #ifdef MODE_UFS2
 /* UFS inode.  */
 struct grub_ufs_inode
@@ -235,6 +236,7 @@ struct grub_ufs_dirent
     };
   };
 } GRUB_PACKED;
+PRAGMA_END_PACKED
 
 /* Information about a "mounted" ufs filesystem.  */
 struct grub_ufs_data
diff --git a/grub-core/fs/xfs.c b/grub-core/fs/xfs.c
index 8e02ab4a3..48c6c8613 100644
--- a/grub-core/fs/xfs.c
+++ b/grub-core/fs/xfs.c
@@ -107,6 +107,7 @@ GRUB_MOD_LICENSE ("GPLv3+");
 	 XFS_SB_FEAT_INCOMPAT_NEEDSREPAIR | \
 	 XFS_SB_FEAT_INCOMPAT_NREXT64)
 
+PRAGMA_BEGIN_PACKED
 struct grub_xfs_sblock
 {
   grub_uint8_t magic[4];
@@ -239,6 +240,7 @@ struct grub_xfs_dirblock_tail
   grub_uint32_t leaf_count;
   grub_uint32_t leaf_stale;
 } GRUB_PACKED;
+PRAGMA_END_PACKED
 
 struct grub_fshelp_node
 {
diff --git a/grub-core/fs/zfs/zfs.c b/grub-core/fs/zfs/zfs.c
index 3fdf9bda8..753703f54 100644
--- a/grub-core/fs/zfs/zfs.c
+++ b/grub-core/fs/zfs/zfs.c
@@ -254,8 +254,8 @@ struct grub_zfs_data
   struct subvolume subvol;
 
   struct grub_zfs_device_desc *devices_attached;
-  unsigned n_devices_attached;
-  unsigned n_devices_allocated;
+  grub_size_t n_devices_attached;
+  grub_size_t n_devices_allocated;
   struct grub_zfs_device_desc *device_original;
 
   uberblock_t current_uberblock;
@@ -2767,7 +2767,9 @@ dnode_get (dnode_end_t * mdn, grub_uint64_t objnum, grub_uint8_t type,
   return GRUB_ERR_NONE;
 }
 
+#ifdef __GNUC__
 #pragma GCC diagnostic ignored "-Wstrict-aliasing"
+#endif
 
 /*
  * Get the file dnode for a given file name where mdn is the meta dnode
diff --git a/grub-core/fs/zfs/zfs_lz4.c b/grub-core/fs/zfs/zfs_lz4.c
index 5453822d0..873445803 100644
--- a/grub-core/fs/zfs/zfs_lz4.c
+++ b/grub-core/fs/zfs/zfs_lz4.c
@@ -74,6 +74,7 @@ static int LZ4_uncompress_unknownOutputSize(const char *source, char *dest,
 #define	S32	grub_int32_t
 #define	U64	grub_uint64_t
 
+PRAGMA_BEGIN_PACKED
 typedef struct _U16_S {
 	U16 v;
 } GRUB_PACKED U16_S;
@@ -83,6 +84,7 @@ typedef struct _U32_S {
 typedef struct _U64_S {
 	U64 v;
 } GRUB_PACKED U64_S;
+PRAGMA_END_PACKED
 
 #define	A64(x)	(((U64_S *)(x))->v)
 #define	A32(x)	(((U32_S *)(x))->v)
diff --git a/grub-core/kern/misc.c b/grub-core/kern/misc.c
index 7cee5d75c..30ff90432 100644
--- a/grub-core/kern/misc.c
+++ b/grub-core/kern/misc.c
@@ -37,7 +37,7 @@ union printf_arg
       INT, LONG, LONGLONG,
       UNSIGNED_INT = 3, UNSIGNED_LONG, UNSIGNED_LONGLONG,
       STRING,
-      GUID
+      UUID
     } type;
   long long ll;
 };
@@ -162,7 +162,7 @@ grub_puts_ (const char *s)
   return grub_puts (_(s));
 }
 
-#if defined (__APPLE__) && ! defined (GRUB_UTIL)
+#if ( defined (__APPLE__) || defined (_MSC_VER) ) && ! defined (GRUB_UTIL)
 int
 grub_err_printf (const char *fmt, ...)
 {
@@ -177,7 +177,7 @@ grub_err_printf (const char *fmt, ...)
 }
 #endif
 
-#if ! defined (__APPLE__) && ! defined (GRUB_UTIL)
+#if ! defined (__APPLE__) && ! defined (_MSC_VER) && ! defined (GRUB_UTIL)
 int grub_err_printf (const char *fmt, ...)
 __attribute__ ((alias("grub_printf")));
 #endif
@@ -900,7 +900,7 @@ parse_printf_arg_fmt (const char *fmt0, struct printf_args *args,
 	  else
 	    args->ptr[curn].type = UNSIGNED_INT;
 	  if (*(fmt) == 'G') {
-	    args->ptr[curn].type = GUID;
+	    args->ptr[curn].type = UUID;
 	    ++fmt;
 	  }
 	  break;
@@ -944,7 +944,7 @@ parse_printf_args (const char *fmt0, struct printf_args *args, va_list args_in)
 	args->ptr[n].ll = va_arg (args_in, long long);
 	break;
       case STRING:
-      case GUID:
+      case UUID:
 	if (sizeof (void *) == sizeof (long long))
 	  args->ptr[n].ll = va_arg (args_in, long long);
 	else
@@ -1149,7 +1149,7 @@ grub_vsnprintf_real (char *str, grub_size_t max_len, const char *fmt0,
 	  {
 	    grub_size_t len = 0;
 	    grub_size_t fill;
-	    const char *p = ((char *) (grub_addr_t) curarg) ? : "(null)";
+	    const char *p = (curarg != 0) ? ((char *) (grub_addr_t) curarg) : "(null)";
 	    grub_size_t i;
 
 	    while (len < format2 && p[len])
diff --git a/grub-core/lib/posix_wrap/limits.h b/grub-core/lib/posix_wrap/limits.h
index 4be7b4080..9f89a0f9d 100644
--- a/grub-core/lib/posix_wrap/limits.h
+++ b/grub-core/lib/posix_wrap/limits.h
@@ -23,8 +23,12 @@
 
 #define UCHAR_MAX GRUB_UCHAR_MAX
 #define USHRT_MAX GRUB_USHRT_MAX
+#ifndef UINT_MAX
 #define UINT_MAX GRUB_UINT_MAX
+#endif
+#ifndef ULONG_MAX
 #define ULONG_MAX GRUB_ULONG_MAX
+#endif
 
 /* gnulib also defines this type */
 #ifndef SIZE_MAX
@@ -35,10 +39,18 @@
 #define SCHAR_MAX GRUB_SCHAR_MAX
 #define SHRT_MIN GRUB_SHRT_MIN
 #define SHRT_MAX GRUB_SHRT_MAX
+#ifndef INT_MIN
 #define INT_MIN GRUB_INT_MIN
+#endif
+#ifndef INT_MAX
 #define INT_MAX GRUB_INT_MAX
+#endif
+#ifndef LONG_MIN
 #define LONG_MIN GRUB_LONG_MIN
+#endif
+#ifndef LONG_MAX
 #define LONG_MAX GRUB_LONG_MAX
+#endif
 
 #define CHAR_BIT 8
 #define WORD_BIT 32
diff --git a/grub-core/lib/xzembed/xz_dec_lzma2.c b/grub-core/lib/xzembed/xz_dec_lzma2.c
index af7b77079..d39f8afc0 100644
--- a/grub-core/lib/xzembed/xz_dec_lzma2.c
+++ b/grub-core/lib/xzembed/xz_dec_lzma2.c
@@ -24,7 +24,9 @@
 #include "xz_private.h"
 #include "xz_lzma2.h"
 
+#ifdef __GNUC__
 #pragma GCC diagnostic warning "-Wattributes"
+#endif
 
 /*
  * Range decoder initialization eats the first five bytes of each LZMA chunk.
diff --git a/grub-core/lib/xzembed/xz_stream.h b/grub-core/lib/xzembed/xz_stream.h
index f58397a15..2a64d1c8d 100644
--- a/grub-core/lib/xzembed/xz_stream.h
+++ b/grub-core/lib/xzembed/xz_stream.h
@@ -32,7 +32,7 @@
 
 #define STREAM_HEADER_SIZE 12
 
-#define HEADER_MAGIC "\3757zXZ\0"
+#define HEADER_MAGIC "\xFD" "7zXZ\0"
 #define HEADER_MAGIC_SIZE 6
 
 #define FOOTER_MAGIC "YZ"
diff --git a/grub-core/lib/zstd/bitstream.h b/grub-core/lib/zstd/bitstream.h
index 2f91460c5..d95b7ed82 100644
--- a/grub-core/lib/zstd/bitstream.h
+++ b/grub-core/lib/zstd/bitstream.h
@@ -161,7 +161,7 @@ MEM_STATIC unsigned BIT_highbit32 (U32 val)
         unsigned long r=0;
         _BitScanReverse ( &r, val );
         return (unsigned) r;
-#   elif defined(__GNUC__) && (__GNUC__ >= 3)   /* Use GCC Intrinsic */
+#   elif defined(__GNUC__) && (__GNUC__ >= 3) && !defined(__riscv)  /* Use GCC Intrinsic */
         return 31 - __builtin_clz (val);
 #   else   /* Software version */
         static const unsigned DeBruijnClz[32] = { 0,  9,  1, 10, 13, 21,  2, 29,
diff --git a/grub-core/lib/zstd/fse_decompress.c b/grub-core/lib/zstd/fse_decompress.c
index 2227b84bc..a08c8fbb2 100644
--- a/grub-core/lib/zstd/fse_decompress.c
+++ b/grub-core/lib/zstd/fse_decompress.c
@@ -36,8 +36,7 @@
 /* **************************************************************
 *  Includes
 ****************************************************************/
-#include <stdlib.h>     /* malloc, free, qsort */
-#include <string.h>     /* memcpy, memset */
+#include "mem.h"
 #include "bitstream.h"
 #include "compiler.h"
 #define FSE_STATIC_LINKING_ONLY
diff --git a/grub-core/lib/zstd/huf_decompress.c b/grub-core/lib/zstd/huf_decompress.c
index 83ecaff01..856866322 100644
--- a/grub-core/lib/zstd/huf_decompress.c
+++ b/grub-core/lib/zstd/huf_decompress.c
@@ -35,7 +35,7 @@
 /* **************************************************************
 *  Dependencies
 ****************************************************************/
-#include <string.h>     /* memcpy, memset */
+#include "mem.h"
 #include "compiler.h"
 #include "bitstream.h"  /* BIT_* */
 #include "fse.h"        /* to compress headers */
diff --git a/grub-core/lib/zstd/mem.h b/grub-core/lib/zstd/mem.h
index 2051bcad1..032ba040d 100644
--- a/grub-core/lib/zstd/mem.h
+++ b/grub-core/lib/zstd/mem.h
@@ -21,6 +21,16 @@ extern "C" {
 #include <stddef.h>     /* size_t, ptrdiff_t */
 #include <string.h>     /* memcpy */
 
+#ifdef GRUB
+#include <grub/mm.h>
+#include <grub/misc.h>
+#define memset grub_memset
+#define memcpy grub_memcpy
+#define memmove grub_memmove
+#define malloc grub_malloc
+#define calloc grub_calloc
+#define free grub_free
+#endif
 
 /*-****************************************
 *  Compiler specifics
@@ -196,7 +206,7 @@ MEM_STATIC void MEM_write64(void* memPtr, U64 value)
 
 MEM_STATIC U32 MEM_swap32(U32 in)
 {
-#if defined(_MSC_VER)     /* Visual Studio */
+#if defined(_MSC_VER) && !defined(GRUB)     /* Visual Studio */
     return _byteswap_ulong(in);
 #elif defined (__GNUC__) && (__GNUC__ * 100 + __GNUC_MINOR__ >= 403)
     return __builtin_bswap32(in);
@@ -210,7 +220,7 @@ MEM_STATIC U32 MEM_swap32(U32 in)
 
 MEM_STATIC U64 MEM_swap64(U64 in)
 {
-#if defined(_MSC_VER)     /* Visual Studio */
+#if defined(_MSC_VER) && !defined(GRUB)     /* Visual Studio */
     return _byteswap_uint64(in);
 #elif defined (__GNUC__) && (__GNUC__ * 100 + __GNUC_MINOR__ >= 403)
     return __builtin_bswap64(in);
diff --git a/grub-core/lib/zstd/xxhash.c b/grub-core/lib/zstd/xxhash.c
index 532b81619..01f4c800a 100644
--- a/grub-core/lib/zstd/xxhash.c
+++ b/grub-core/lib/zstd/xxhash.c
@@ -97,8 +97,7 @@
 ***************************************/
 /* Modify the local functions below should you wish to use some other memory routines */
 /* for malloc(), free() */
-#include <stdlib.h>
-#include <stddef.h>     /* size_t */
+#include "mem.h"
 static void* XXH_malloc(size_t s) { return malloc(s); }
 static void  XXH_free  (void* p)  { free(p); }
 /* for memcpy() */
@@ -202,7 +201,7 @@ static U64 XXH_read64(const void* memPtr)
 #define GCC_VERSION (__GNUC__ * 100 + __GNUC_MINOR__)
 
 /* Note : although _rotl exists for minGW (GCC under windows), performance seems poor */
-#if defined(_MSC_VER)
+#if defined(_MSC_VER) && !defined(GRUB)
 #  define XXH_rotl32(x,r) _rotl(x,r)
 #  define XXH_rotl64(x,r) _rotl64(x,r)
 #else
@@ -210,7 +209,7 @@ static U64 XXH_read64(const void* memPtr)
 #  define XXH_rotl64(x,r) ((x << r) | (x >> (64 - r)))
 #endif
 
-#if defined(_MSC_VER)     /* Visual Studio */
+#if defined(_MSC_VER) && !defined(GRUB)     /* Visual Studio */
 #  define XXH_swap32 _byteswap_ulong
 #  define XXH_swap64 _byteswap_uint64
 #elif GCC_VERSION >= 403
diff --git a/grub-core/lib/zstd/zstd_common.c b/grub-core/lib/zstd/zstd_common.c
index 6f05d240e..568cebd79 100644
--- a/grub-core/lib/zstd/zstd_common.c
+++ b/grub-core/lib/zstd/zstd_common.c
@@ -13,8 +13,7 @@
 /*-*************************************
 *  Dependencies
 ***************************************/
-#include <stdlib.h>      /* malloc, calloc, free */
-#include <string.h>      /* memset */
+#include "mem.h"
 #include "error_private.h"
 #include "zstd_internal.h"
 
diff --git a/grub-core/lib/zstd/zstd_decompress.c b/grub-core/lib/zstd/zstd_decompress.c
index e4b5670c2..b3397f411 100644
--- a/grub-core/lib/zstd/zstd_decompress.c
+++ b/grub-core/lib/zstd/zstd_decompress.c
@@ -55,7 +55,6 @@
 /*-*******************************************************
 *  Dependencies
 *********************************************************/
-#include <string.h>      /* memcpy, memmove, memset */
 #include "compiler.h"    /* prefetch */
 #include "cpu.h"         /* bmi2 */
 #include "mem.h"         /* low level memory routines */
diff --git a/grub-core/lib/zstd/zstd_internal.h b/grub-core/lib/zstd/zstd_internal.h
index e75adfa61..05b222069 100644
--- a/grub-core/lib/zstd/zstd_internal.h
+++ b/grub-core/lib/zstd/zstd_internal.h
@@ -67,12 +67,24 @@ static const U32 repStartValue[ZSTD_REP_NUM] = { 1, 4, 8 };
 #define MB *(1 <<20)
 #define GB *(1U<<30)
 
+#ifndef BIT7
 #define BIT7 128
+#endif
+#ifndef BIT6
 #define BIT6  64
+#endif
+#ifndef BIT5
 #define BIT5  32
+#endif
+#ifndef BIT4
 #define BIT4  16
+#endif
+#ifndef BIT1
 #define BIT1   2
+#endif
+#ifndef BIT0
 #define BIT0   1
+#endif
 
 #define ZSTD_WINDOWLOG_ABSOLUTEMIN 10
 #define ZSTD_WINDOWLOG_DEFAULTMAX 27 /* Default maximum allowed window log */
@@ -215,7 +227,7 @@ MEM_STATIC U32 ZSTD_highbit32(U32 val)   /* compress, dictBuilder, decodeCorpus
         unsigned long r=0;
         _BitScanReverse(&r, val);
         return (unsigned)r;
-#   elif defined(__GNUC__) && (__GNUC__ >= 3)   /* GCC Intrinsic */
+#   elif defined(__GNUC__) && (__GNUC__ >= 3) && !defined(__riscv)  /* GCC Intrinsic */
         return 31 - __builtin_clz(val);
 #   else   /* Software version */
         static const U32 DeBruijnClz[32] = { 0, 9, 1, 10, 13, 21, 2, 29, 11, 14, 16, 18, 22, 25, 3, 30, 8, 12, 20, 28, 15, 17, 24, 7, 19, 27, 23, 6, 26, 5, 4, 31 };
diff --git a/include/grub/arm64/types.h b/include/grub/arm64/types.h
index d132c5eab..54b5e6398 100644
--- a/include/grub/arm64/types.h
+++ b/include/grub/arm64/types.h
@@ -23,7 +23,11 @@
 #define GRUB_TARGET_SIZEOF_VOID_P	8
 
 /* The size of long.  */
+#if defined(_MSC_VER)
+#define GRUB_TARGET_SIZEOF_LONG		4
+#else
 #define GRUB_TARGET_SIZEOF_LONG		8
+#endif
 
 /* currently only support little-endian.  */
 #undef GRUB_TARGET_WORDS_BIGENDIAN
diff --git a/include/grub/btrfs.h b/include/grub/btrfs.h
index 9d93fb6c1..07a1b5d80 100644
--- a/include/grub/btrfs.h
+++ b/include/grub/btrfs.h
@@ -45,13 +45,14 @@ struct grub_btrfs_root_item
   grub_uint64_t inode;
 };
 
+PRAGMA_BEGIN_PACKED
 struct grub_btrfs_key
 {
   grub_uint64_t object_id;
   grub_uint8_t type;
   grub_uint64_t offset;
 } GRUB_PACKED;
-
+PRAGMA_END_PACKED
 
 struct grub_btrfs_root_backref
 {
diff --git a/include/grub/exfat.h b/include/grub/exfat.h
index 2b8009cee..b7654d0aa 100644
--- a/include/grub/exfat.h
+++ b/include/grub/exfat.h
@@ -21,6 +21,7 @@
 
 #include <grub/types.h>
 
+PRAGMA_BEGIN_PACKED
 struct grub_exfat_bpb
 {
   grub_uint8_t jmp_boot[3];
@@ -42,6 +43,7 @@ struct grub_exfat_bpb
   grub_uint8_t num_ph_drive;
   grub_uint8_t reserved[8];
 } GRUB_PACKED;
+PRAGMA_END_PACKED
 
 #ifdef GRUB_UTIL
 #include <grub/disk.h>
diff --git a/include/grub/fat.h b/include/grub/fat.h
index 8d7e4a1e5..bf4441479 100644
--- a/include/grub/fat.h
+++ b/include/grub/fat.h
@@ -21,6 +21,7 @@
 
 #include <grub/types.h>
 
+PRAGMA_BEGIN_PACKED
 struct grub_fat_bpb
 {
   grub_uint8_t jmp_boot[3];
@@ -66,6 +67,7 @@ struct grub_fat_bpb
     } GRUB_PACKED fat32;
   } GRUB_PACKED version_specific;
 } GRUB_PACKED;
+PRAGMA_END_PACKED
 
 #ifdef GRUB_UTIL
 #include <grub/disk.h>
diff --git a/include/grub/hfs.h b/include/grub/hfs.h
index e27993c42..7a1008778 100644
--- a/include/grub/hfs.h
+++ b/include/grub/hfs.h
@@ -24,6 +24,7 @@
 #define GRUB_HFS_MAGIC		0x4244
 
 /* A single extent.  A file consists of one or more extents.  */
+PRAGMA_BEGIN_PACKED
 struct grub_hfs_extent
 {
   /* The first physical block.  */
@@ -68,5 +69,6 @@ struct grub_hfs_sblock
   grub_uint32_t catalog_size;
   grub_hfs_datarecord_t catalog_recs;
 } GRUB_PACKED;
+PRAGMA_END_PACKED
 
 #endif /* ! GRUB_HFS_HEADER */
diff --git a/include/grub/hfsplus.h b/include/grub/hfsplus.h
index 2d8336aff..8627dc47e 100644
--- a/include/grub/hfsplus.h
+++ b/include/grub/hfsplus.h
@@ -24,6 +24,7 @@
 #define GRUB_HFSPLUS_SBLOCK 2
 
 /* A HFS+ extent.  */
+PRAGMA_BEGIN_PACKED
 struct grub_hfsplus_extent
 {
   /* The first block of a file on disk.  */
@@ -68,6 +69,7 @@ struct grub_hfsplus_volheader
   struct grub_hfsplus_forkdata attr_file;
   struct grub_hfsplus_forkdata startup_file;
 } GRUB_PACKED;
+PRAGMA_END_PACKED
 
 struct grub_hfsplus_compress_index
 {
@@ -140,6 +142,7 @@ struct grub_hfsplus_extkey_internal
   grub_uint8_t type;
 };
 
+PRAGMA_BEGIN_PACKED
 struct grub_hfsplus_attrkey
 {
   grub_uint16_t keylen;
@@ -149,6 +152,7 @@ struct grub_hfsplus_attrkey
   grub_uint16_t namelen;
   grub_uint16_t name[0];
 } GRUB_PACKED;
+PRAGMA_END_PACKED
 
 struct grub_hfsplus_attrkey_internal
 {
@@ -168,6 +172,7 @@ struct grub_hfsplus_key_internal
 };
 
 /* The on disk layout of a catalog key.  */
+PRAGMA_BEGIN_PACKED
 struct grub_hfsplus_catkey
 {
   grub_uint16_t keylen;
@@ -206,6 +211,7 @@ struct grub_hfsplus_btnode
   grub_uint16_t count;
   grub_uint16_t unused;
 } GRUB_PACKED;
+PRAGMA_END_PACKED
 
 /* Return the offset of the record with the index INDEX, in the node
    NODE which is part of the B+ tree BTREE.  */
diff --git a/include/grub/misc.h b/include/grub/misc.h
index 1578f36c3..e2705282e 100644
--- a/include/grub/misc.h
+++ b/include/grub/misc.h
@@ -32,7 +32,9 @@
 #define ALIGN_UP_OVERHEAD(addr, align) ((-(addr)) & ((typeof (addr)) (align) - 1))
 #define ALIGN_DOWN(addr, align) \
 	((addr) & ~((typeof (addr)) (align) - 1))
+#ifndef ARRAY_SIZE
 #define ARRAY_SIZE(array) (sizeof (array) / sizeof (array[0]))
+#endif
 #define COMPILE_TIME_ASSERT(cond) switch (0) { case 1: case !(cond): ; }
 
 #define grub_dprintf(condition, ...) grub_real_dprintf(GRUB_FILE, __LINE__, condition, __VA_ARGS__)
@@ -292,6 +294,9 @@ grub_uuidcasecmp (const char *uuid1, const char *uuid2, grub_size_t n)
  *  ... or ...
  *  l = grub_strtoul(s, (const char ** const)&end, 10);
  */
+#ifdef _MSC_VER
+#define restrict
+#endif
 unsigned long EXPORT_FUNC(grub_strtoul) (const char * restrict str, const char ** const restrict end, int base);
 unsigned long long EXPORT_FUNC(grub_strtoull) (const char * restrict str, const char ** const restrict end, int base);
 
diff --git a/include/grub/ntfs.h b/include/grub/ntfs.h
index d1a6af696..203e0141e 100644
--- a/include/grub/ntfs.h
+++ b/include/grub/ntfs.h
@@ -101,6 +101,7 @@ enum
     GRUB_NTFS_RF_BLNK		= 1
   };
 
+PRAGMA_BEGIN_PACKED
 struct grub_ntfs_bpb
 {
   grub_uint8_t jmp_boot[3];
@@ -126,6 +127,7 @@ struct grub_ntfs_bpb
   grub_uint64_t num_serial;
   grub_uint32_t checksum;
 } GRUB_PACKED;
+PRAGMA_END_PACKED
 
 struct grub_ntfs_attr
 {
diff --git a/include/grub/safemath.h b/include/grub/safemath.h
index e032f63a0..095695bda 100644
--- a/include/grub/safemath.h
+++ b/include/grub/safemath.h
@@ -47,6 +47,30 @@
   __failed;						\
 })
 
+#elif defined(_MSC_VER)
+
+#include <intsafe.h>
+#include <stdbool.h>
+#include <intrin.h>
+
+#define grub_add(a, b, res)	UIntPtrAdd(a, b, res)
+#define grub_sub(a, b, res)	UIntPtrSub(a, b, res)
+#define grub_mul(a, b, res)	UIntPtrMult(a, b, res)
+
+#define grub_cast(a, res)	grub_add ((a), 0, (res))
+
+// Only used by EROFS for now...
+static __inline bool ALIGN_UP_OVF(uintptr_t v, uintptr_t align, uintptr_t* res)
+{
+  bool __failed;
+  uintptr_t __a = ((uintptr_t)(align) - 1);
+
+  __failed = FAILED(grub_add (v, __a, res));
+  if (__failed == false)
+    *(res) &= ~__a;
+  return __failed;
+}
+
 #else
 #error gcc 5.1 or newer or clang 8.0 or newer is required
 #endif
diff --git a/include/grub/term.h b/include/grub/term.h
index 7f1a14c84..6daa584a1 100644
--- a/include/grub/term.h
+++ b/include/grub/term.h
@@ -339,12 +339,12 @@ void grub_term_restore_pos (struct grub_term_coordinate *pos);
 
 static inline unsigned grub_term_width (struct grub_term_output *term)
 {
-  return term->getwh(term).x ? : 80;
+  return term->getwh(term).x ? term->getwh(term).x : 80;
 }
 
 static inline unsigned grub_term_height (struct grub_term_output *term)
 {
-  return term->getwh(term).y ? : 24;
+  return term->getwh(term).y ? term->getwh(term).y : 24;
 }
 
 static inline struct grub_term_coordinate
diff --git a/include/grub/types.h b/include/grub/types.h
index 45079bf65..5f661f999 100644
--- a/include/grub/types.h
+++ b/include/grub/types.h
@@ -27,10 +27,20 @@
 
 #ifdef __MINGW32__
 #define GRUB_PACKED __attribute__ ((packed,gcc_struct))
+#elif defined(_MSC_VER)
+#define GRUB_PACKED
 #else
 #define GRUB_PACKED __attribute__ ((packed))
 #endif
 
+#ifdef _MSC_VER
+#define PRAGMA_BEGIN_PACKED __pragma(pack(push, 1))
+#define PRAGMA_END_PACKED   __pragma(pack(pop))
+#else
+#define PRAGMA_BEGIN_PACKED
+#define PRAGMA_END_PACKED
+#endif
+
 #ifdef GRUB_BUILD
 # define GRUB_CPU_SIZEOF_VOID_P	BUILD_SIZEOF_VOID_P
 # define GRUB_CPU_SIZEOF_LONG	BUILD_SIZEOF_LONG
@@ -199,19 +209,17 @@ static inline grub_uint16_t grub_swap_bytes16(grub_uint16_t _x)
 #define grub_swap_bytes16_compile_time(x) ((grub_uint16_t)((((x) & 0xff) << 8) | (((x) & 0xff00) >> 8)))
 #define grub_swap_bytes32_compile_time(x) ((grub_uint32_t)((((x) & 0xff) << 24) | (((x) & 0xff00) << 8) | (((x) & 0xff0000) >> 8) | (((x) & 0xff000000UL) >> 24)))
 #define grub_swap_bytes64_compile_time(x)	\
-({ \
-   grub_uint64_t _x = (x); \
-   (grub_uint64_t) ((_x << 56) \
-                    | ((_x & (grub_uint64_t) 0xFF00ULL) << 40) \
-                    | ((_x & (grub_uint64_t) 0xFF0000ULL) << 24) \
-                    | ((_x & (grub_uint64_t) 0xFF000000ULL) << 8) \
-                    | ((_x & (grub_uint64_t) 0xFF00000000ULL) >> 8) \
-                    | ((_x & (grub_uint64_t) 0xFF0000000000ULL) >> 24) \
-                    | ((_x & (grub_uint64_t) 0xFF000000000000ULL) >> 40) \
-                    | (_x >> 56)); \
-})
-
-#if (defined(__GNUC__) && (__GNUC__ > 3) && (__GNUC__ > 4 || __GNUC_MINOR__ >= 3)) || defined(__clang__)
+((grub_uint64_t) ((((grub_uint64_t)x) << 56) \
+                    | ((((grub_uint64_t)x) & (grub_uint64_t) 0xFF00ULL) << 40) \
+                    | ((((grub_uint64_t)x) & (grub_uint64_t) 0xFF0000ULL) << 24) \
+                    | ((((grub_uint64_t)x) & (grub_uint64_t) 0xFF000000ULL) << 8) \
+                    | ((((grub_uint64_t)x) & (grub_uint64_t) 0xFF00000000ULL) >> 8) \
+                    | ((((grub_uint64_t)x) & (grub_uint64_t) 0xFF0000000000ULL) >> 24) \
+                    | ((((grub_uint64_t)x) & (grub_uint64_t) 0xFF000000000000ULL) >> 40) \
+                    | (((grub_uint64_t)x) >> 56)) \
+)
+
+#if ((defined(__GNUC__) && (__GNUC__ > 3) && (__GNUC__ > 4 || __GNUC_MINOR__ >= 3)) || defined(__clang__)) && (!defined (__riscv))
 static inline grub_uint32_t grub_swap_bytes32(grub_uint32_t x)
 {
 	return __builtin_bswap32(x);
@@ -286,18 +294,24 @@ static inline grub_uint64_t grub_swap_bytes64(grub_uint64_t _x)
 
 #endif /* ! WORDS_BIGENDIAN */
 
+PRAGMA_BEGIN_PACKED
 struct grub_unaligned_uint16
 {
   grub_uint16_t val;
 } GRUB_PACKED;
+PRAGMA_END_PACKED
+PRAGMA_BEGIN_PACKED
 struct grub_unaligned_uint32
 {
   grub_uint32_t val;
 } GRUB_PACKED;
+PRAGMA_END_PACKED
+PRAGMA_BEGIN_PACKED
 struct grub_unaligned_uint64
 {
   grub_uint64_t val;
 } GRUB_PACKED;
+PRAGMA_END_PACKED
 
 typedef struct grub_unaligned_uint16 grub_unaligned_uint16_t;
 typedef struct grub_unaligned_uint32 grub_unaligned_uint32_t;
@@ -338,10 +352,12 @@ static inline grub_uint64_t grub_get_unaligned64 (const void *ptr)
 
 static inline void grub_set_unaligned64 (void *ptr, grub_uint64_t val)
 {
+  PRAGMA_BEGIN_PACKED
   struct grub_unaligned_uint64_t
   {
     grub_uint64_t d;
   } GRUB_PACKED;
+  PRAGMA_END_PACKED
   struct grub_unaligned_uint64_t *dd = (struct grub_unaligned_uint64_t *) ptr;
   dd->d = val;
 }
diff --git a/include/grub/unicode.h b/include/grub/unicode.h
index 9360b0b97..37bf6158f 100644
--- a/include/grub/unicode.h
+++ b/include/grub/unicode.h
@@ -29,6 +29,7 @@ struct grub_unicode_bidi_pair
   grub_uint32_t replace;
 };
 
+PRAGMA_BEGIN_PACKED
 struct grub_unicode_compact_range
 {
   unsigned start:21;
@@ -38,6 +39,7 @@ struct grub_unicode_compact_range
   unsigned bidi_mirror:1;
   unsigned join_type:3;
 } GRUB_PACKED;
+PRAGMA_END_PACKED
 
 /* Old-style Arabic shaping. Used for "visual UTF-8" and
    in grub-mkfont to find variant glyphs in absence of GPOS tables.  */
diff --git a/include/grub/x86_64/types.h b/include/grub/x86_64/types.h
index 0bbdc6d01..eefa80847 100644
--- a/include/grub/x86_64/types.h
+++ b/include/grub/x86_64/types.h
@@ -27,7 +27,7 @@
 #endif
 
 /* The size of long.  */
-#if defined(__MINGW32__) || defined(__ILP32__)
+#if defined(__MINGW32__) || defined(__ILP32__) || defined(_MSC_VER)
 #define GRUB_TARGET_SIZEOF_LONG		4
 #else
 #define GRUB_TARGET_SIZEOF_LONG		8
diff --git a/include/grub/zfs/zap_leaf.h b/include/grub/zfs/zap_leaf.h
index 11447c166..0479d383f 100644
--- a/include/grub/zfs/zap_leaf.h
+++ b/include/grub/zfs/zap_leaf.h
@@ -86,11 +86,13 @@ typedef union zap_leaf_chunk {
 	} l_entry;
 	struct zap_leaf_array {
 		grub_uint8_t la_type;		/* always ZAP_CHUNK_ARRAY */
+		PRAGMA_BEGIN_PACKED
 		union
 		{
 			grub_uint8_t la_array[ZAP_LEAF_ARRAY_BYTES];
 			grub_uint64_t la_array64;
 		} GRUB_PACKED;
+		PRAGMA_END_PACKED
 		grub_uint16_t la_next;		/* next blk or CHAIN_END */
 	} l_array;
 	struct zap_leaf_free {
diff --git a/include/grub/zfs/zio.h b/include/grub/zfs/zio.h
index 997b0c4d4..88dcce269 100644
--- a/include/grub/zfs/zio.h
+++ b/include/grub/zfs/zio.h
@@ -27,10 +27,12 @@
 
 #define	ZEC_MAGIC	0x210da7ab10c7a11ULL	/* zio data bloc tail */
 
+PRAGMA_BEGIN_PACKED
 typedef struct zio_eck {
 	grub_uint64_t	zec_magic;	/* for validation, endianness	*/
 	zio_cksum_t	zec_cksum;	/* 256-bit checksum		*/
 } GRUB_PACKED zio_eck_t;
+PRAGMA_END_PACKED
 
 /*
  * Gang block headers are self-checksumming and contain an array
-- 
2.45.2.windows.1

